- 熟悉Yargs脚手架开发框架
- 熟悉多Package管理工具lerna的使用方法和实现原理
- 深入理解Node.js模块路径解析流程

# yargs
- 脚手架构成
  - bin：`package.json`中配置`bin`字段, 本地开发通过`npm link`安装
  - command: 命令
  - options：参数
  - 文件顶部添加`#!/usr/bin/env node`
- 脚手架初始化流程
  - 构造函数：Yargs()
  - 常用方法：
    - Yargs.options
    - Yargs.option
    - Yargs.group
    - Yargs.demandCommand
    - Yargs.recommendCommands
    - Yargs.strict
    - Yargs.fail
    - Yargs.alias
    - Yargs.wrap
    - Yargs.epilogue
- 脚手架参数解析
  - hideBin(process.argv)/Yargs.argv
  - Yargs.parse(argv, options)
- 命令注册方法
  - Yargs.command(command, describe, builder, handler)
  - Yargs.command({ command, describe, builder, handler })

# lerna
- lerna 是基于git + npm 的多package项目管理工具
- 实现原理：
  - 通过import-local优先调用本地的lerna命令
  - 通过Yargs生成脚手架，先注册全局属性，再注册命令，最后通过parse 方法解析参数
  - lerna命令注册时需要传入builder和handler两个方法，builder方法用于注册命令专属的options，handler用户处理命令的业务逻辑
  - lerna 通过配置npm 本地依赖的方式进行本地开发，具体写法在package.json的依赖中写入：file:xxx，在lerna publish 事会自动将该路径替换

# Node.js模块路径解析流程
- Nodejs 项目模块路径解析是通过require.resolve方法事项的
- require.resolve就是通过Module._resolveFileName方法实现的
- require.resolve实现原理：
  - Module._resolveFileName 方法核心流程的3点：
    - 判断是否为内置模块
    - 通过Module._resolveLookupPaths方法生成node_modules可能存在的路径
    - 通过Module._findPath查询模块的真实路径
  - Module._findPath核心流程有4点：
    - 查询缓存（将request（模块名称）和paths通过\x00合并成cacheKey）
    - 遍历paths，将path与request组成文件路径basePath
    - 如果basePath存在则调用fs.realPathSync获取文件真实路径
    - 将文件真实路径缓存再Module._pathCache（key就是前面生成的cacheKey）
  - fs.realPathSync核心流程有3点：
    - 查询缓存（缓存的key为p，即Module._findPath中生成的文件路径）
    - 从左到右遍历路径字符串，查询到 / 时，拆分路径，判断该路径是否为软连接，如果是软连接则查询真实链接，并生成新路径p，然后继续往后遍历，这里有一个细节需要特别注意：
      - 遍历过程中生成的子路径base会缓存再knowHard和cache中，避免重复查询
    - 遍历完成得到模块对应的真实路径，此时会将原始路径original作为key，真实路径作为value，保存到缓存中

- require.resolve.paths等价于Module._resolveLookupPaths，该方法用于获取所有的node_modules可能存在的路径。
- require.resolve.paths实现原理：
  - 如果路径为 / (根目录)，直接返回['node_modules']
  - 否则，将路径字符串从后往前遍历，查询到 / 时，拆分路径，再后见加上node_modules，并传入一个paths数组中，知道查询不到 / 后返回 paths数组